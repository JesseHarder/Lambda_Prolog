Below, I outline my idea of how I COULD have done application. I say COULD have,
because it turns out apply/2 is already a predicate built into Prolog.

Table of Contents:
1) My Idea
2) How it works in Prolog

*** Part 1 - My Idea ***

The basic idea I had was that every lambda calculus feature predicate included
needs to have one or more apply() rules written for it, just as with the
typing rules. In general, these will look like the example below.

Example:
Say we have a predicate that simulates a lambda function wanting two
input variables. We need one apply rule for 1 variable and 2 vairables
and another for after the first has been applied.

% Rule for applying both inputs.
apply(predicate(X,Y,Z), Input1, Input2, Result) :-
		var(X), % to check that X is the first variable.
		apply(predicate(Input1, Y, Z), Input2, Result).

% Rule for applying the second input.
apply(predicate(_,Y,Z), Input2, Result) :-
		var(Y), % to check that Y is unbound variable.
		Result = predicate(Input1, Input2, Z),
		predicate(Input1, Input2, Z).

Note: This last line should only be included if application should also
perform an evaluation.

*** Part 2 ***

As stated above, apply/2 is already a built in predicate in Prolog. The
documentation, found at http://www.swi-prolog.org/pldoc/man?predicate=apply/2,
says:

apply(:Goal, +List)
    Append the members of List to the arguments of Goal and call the resulting
term. For example: apply(plus(1), [2, X]) calls plus(1, 2, X). New code should
use call/[2..] if the length of List is fixed.

As a result, the only major thing of note is that, working with my Prolog
predicate implementation of lambda calculus features, you need to make sure
to include in your application the variable at the end for getting the result.
